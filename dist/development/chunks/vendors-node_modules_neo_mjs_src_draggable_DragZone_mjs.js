(self["webpackChunkcovid19_gallery"] = self["webpackChunkcovid19_gallery"] || []).push([["vendors-node_modules_neo_mjs_src_draggable_DragZone_mjs"],{

/***/ "./node_modules/neo.mjs/src/draggable/DragProxyComponent.mjs":
/*!*******************************************************************!*\
  !*** ./node_modules/neo.mjs/src/draggable/DragProxyComponent.mjs ***!
  \*******************************************************************/
/*! namespace exports */
/*! export default [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_require__, __webpack_require__.r, __webpack_exports__, __webpack_require__.d, __webpack_require__.* */
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => /* binding */ DragProxyComponent
/* harmony export */ });
/* harmony import */ var _component_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../component/Base.mjs */ "./node_modules/neo.mjs/src/component/Base.mjs");


/**
 * @class Neo.draggable.DragProxyComponent
 * @extends Neo.component.Base
 */
class DragProxyComponent extends _component_Base_mjs__WEBPACK_IMPORTED_MODULE_0__.default {
    static getConfig() {return {
        /**
         * @member {String} className='Neo.draggable.DragProxyComponent'
         * @protected
         */
        className: 'Neo.draggable.DragProxyComponent',
        /**
         * @member {String} ntype='dragproxy'
         * @protected
         */
        ntype: 'dragproxy',
        /**
         * @member {Boolean} autoMount=true
         */
        autoMount: true,
        /**
         * @member {Boolean} autoRender=true
         */
        autoRender: true,
        /**
         * @member {String[]} cls=['neo-dragproxy']
         */
        cls: ['neo-dragproxy'],
        /**
         * @member {Boolean} moveInMainThread=true
         */
        moveInMainThread: true
    }}

    /**
     *
     * @param {Object} config
     */
    constructor(config) {
        super(config);

        let me = this;

        me.on('mounted', me.onMounted, me);
    }

    /**
     *
     * @param {String} id
     */
    onMounted(id) {
        if (this.moveInMainThread) {
            Neo.main.addon.DragDrop.setDragProxyElement({
                id: id
            });
        }
    }
}

Neo.applyClassConfig(DragProxyComponent);



/***/ }),

/***/ "./node_modules/neo.mjs/src/draggable/DragZone.mjs":
/*!*********************************************************!*\
  !*** ./node_modules/neo.mjs/src/draggable/DragZone.mjs ***!
  \*********************************************************/
/*! namespace exports */
/*! export default [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_require__, __webpack_require__.r, __webpack_exports__, __webpack_require__.d, __webpack_require__.* */
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => /* binding */ DragZone
/* harmony export */ });
/* harmony import */ var _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base.mjs */ "./node_modules/neo.mjs/src/core/Base.mjs");
/* harmony import */ var _DragProxyComponent_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./DragProxyComponent.mjs */ "./node_modules/neo.mjs/src/draggable/DragProxyComponent.mjs");
/* harmony import */ var _util_Array_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/Array.mjs */ "./node_modules/neo.mjs/src/util/Array.mjs");
/* harmony import */ var _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/VDom.mjs */ "./node_modules/neo.mjs/src/util/VDom.mjs");





/**
 * @class Neo.draggable.DragZone
 * @extends Neo.core.Base
 */
class DragZone extends _core_Base_mjs__WEBPACK_IMPORTED_MODULE_0__.default {
    static getStaticConfig() {return {
        /**
         * True automatically applies the core/Observable.mjs mixin
         * @member {Boolean} observable=true
         * @static
         */
        observable: true
    }}

    static getConfig() {return {
        /**
         * @member {String} className='Neo.draggable.DragZone'
         * @protected
         */
        className: 'Neo.draggable.DragZone',
        /**
         * @member {String} ntype='dragzone'
         * @protected
         */
        ntype: 'dragzone',
        /**
         * Adds this.dragProxyCls => 'neo-dragproxy' to the top level dragProxyEl node
         * @member {Boolean} addDragProxyCls=true
         */
        addDragProxyCls: true,
        /**
         * drag:move will by default only fire in case moveInMainThread === false.
         * In case you want to move the dragProxy inside main but still get the event,
         * set this config to true.
         * @member {Boolean} alwaysFireDragMove=false
         */
        alwaysFireDragMove: false,
        /**
         * The name of the App this instance belongs to
         * @member {String|null} appName=null
         */
        appName: null,
        /**
         * @member {String|null} boundaryContainerId=null
         */
        boundaryContainerId: null,
        /**
         * Store data which you want to pass to drop related events here
         * @member {Object|null} data=null
         */
        data: null,
        /**
         * The vdom (tree) of the element you want to drag
         * @member {Object|null} dragElement=null
         */
        dragElement: null,
        /**
         * The bounding client rect of the dragElement
         * Will get set inside dragStart()
         * @member {Object|null} dragElementRect=null
         */
        dragElementRect: null,
        /**
         * @member {Neo.component.Base|null} dragProxy=null
         * @protected
         */
        dragProxy: null,
        /**
         * @member {Object|null} dragProxyConfig=null
         */
        dragProxyConfig_: null,
        /**
         * @member {String} dragProxyCls='neo-dragproxy'
         */
        dragProxyCls: 'neo-dragproxy',
        /**
         * You can either pass an array of (dom) ids or cls rules or both
         * @example
         * dropZoneIdentifier: {
         *     ids: ['foo','bar']
         * }
         * @example
         * dropZoneIdentifier: {
         *     cls: ['my-class-1','my-class-2']
         * }
         * @example
         * dropZoneIdentifier: {
         *     cls: ['my-class-1','my-class-2'],
         *     ids: ['foo','bar']
         * }
         * @member {Object|null} dropZoneIdentifier=null
         */
        dropZoneIdentifier: null,
        /**
         * @member {Boolean} moveHorizontal=true
         */
        moveHorizontal: true,
        /**
         * @member {Boolean} moveInMainThread=true
         */
        moveInMainThread: true,
        /**
         * @member {Boolean} moveVertical=true
         */
        moveVertical: true,
        /**
         * @member {Number} offsetX=0
         */
        offsetX: 0,
        /**
         * @member {Number} offsetY=0
         */
        offsetY: 0,
        /**
         * @member {Neo.component.Base} owner=null
         */
        owner: null,
        /**
         * @member {String} proxyParentId_='document.body'
         */
        proxyParentId_: 'document.body',
        /**
         * @member {String|null} scrollContainerId=null
         */
        scrollContainerId: null,
        /**
         * @member {Number} scrollFactorLeft=1
         */
        scrollFactorLeft: 1,
        /**
         * @member {Number} scrollFactorTop=1
         */
        scrollFactorTop: 1,
        /**
         * True creates a position:absolute wrapper div which contains the cloned element
         * @member {Boolean} useProxyWrapper=true
         */
        useProxyWrapper: true
    }}

    /**
     *
     * @param {Object} config
     */
    constructor(config) {
        super(config);

        if (!Neo.main.addon.DragDrop) {
            console.error('You can not use Neo.draggable.DragZone without adding Neo.main.addon.DragDrop to the main thread addons', this.id);
        }
    }

    /**
     * Triggered when accessing the dragProxyConfig config
     * We are re-using this config to create multiple dragProxies,
     * so it is important to work with a clone. see: createDragProxy()
     * @param {Object} value
     * @protected
     */
    beforeGetDragProxyConfig(value) {
        return Neo.clone(value, true, true);
    }

    /**
     *
     * @param {Object} data
     */
    createDragProxy(data) {
        let me        = this,
            component = Neo.getComponent(me.getDragElementRoot().id) || me.owner,
            clone     = _util_VDom_mjs__WEBPACK_IMPORTED_MODULE_3__.default.clone(me.dragElement),
            rect      = me.dragElementRect;

        const config = {
            module          : _DragProxyComponent_mjs__WEBPACK_IMPORTED_MODULE_1__.default,
            appName         : me.appName,
            moveInMainThread: me.moveInMainThread,
            parentId        : me.proxyParentId,
            vdom            : me.useProxyWrapper ? {cn: [clone]} : clone,

            style: {
                height: `${data.height}px`,
                left  : `${me.moveHorizontal ? data.x : rect.x}px`,
                top   : `${me.moveVertical   ? data.y : rect.y}px`,
                width : `${data.width}px`
            },

            ...me.dragProxyConfig || {}
        };

        config.cls = config.cls || [];

        if (component) {
            config.cls.push(component.getTheme());
        }

        if (!me.useProxyWrapper) {
            config.cls.push(...clone.cls);
        }

        if (me.addDragProxyCls && config.cls) {
            _util_Array_mjs__WEBPACK_IMPORTED_MODULE_2__.default.add(config.cls, me.dragProxyCls);
        }

        me.dragProxy = Neo.create(config);
    }

    /**
     * Override for using custom animations
     */
    destroyDragProxy() {
        let me = this,
            id = me.dragProxy.id;

        setTimeout(() => {
            Neo.currentWorker.promiseMessage('main', {
                action: 'updateDom',
                deltas: [{action: 'removeNode', id: id}]
            });
        }, me.moveInMainThread ? 0 : 30);

        me.dragProxy.destroy();
    }

    /**
     *
     */
    dragEnd() {
        let me    = this,
            owner = me.owner,
            cls   = owner.cls;

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_2__.default.remove(cls, 'neo-is-dragging');
        owner.cls = cls;

        if (me.dragProxy) {
            me.destroyDragProxy();
            me.dragProxy = null;
        }

        Object.assign(me, {
            dragElementRect  : null,
            offsetX          : 0,
            offsetY          : 0,
            scrollContainerId: null
        });

        me.resetData();
    }

    /**
     *
     * @param {Object} data
     */
    dragMove(data) {
        let me = this,
            style;

        if (!me.moveInMainThread && me.dragProxy) {
            style = me.dragProxy.style;

            if (me.moveHorizontal) {
                style.left = `${data.clientX - me.offsetX}px`;
            }

            if (me.moveVertical) {
                style.top = `${data.clientY - me.offsetY}px`;
            }

            me.dragProxy.style = style;
        }
    }

    /**
     *
     * @param {Object} data
     */
    dragStart(data) {
        let me    = this,
            owner = me.owner,
            cls   = owner.cls;

        me.setData();

        _util_Array_mjs__WEBPACK_IMPORTED_MODULE_2__.default.add(cls, 'neo-is-dragging');
        owner.cls = cls;

        Neo.main.addon.DragDrop.setConfigs(me.getMainThreadConfigs());

        Neo.main.DomAccess.getBoundingClientRect({
            id: me.getDragElementRoot().id
        }).then(rect => {
            Object.assign(me, {
                dragElementRect: rect,
                offsetX        : data.clientX - rect.left,
                offsetY        : data.clientY - rect.top
            });

            me.createDragProxy(rect);
        });
    }

    /**
     * Override this method in case you want to wrap your dragElement.
     * See: draggable.tree.DragZone
     * @returns {Object}
     */
    getDragElementRoot() {
        return this.dragElement;
    }

    /**
     * Override this method inside class extensions to add more configs
     * which get passed to main.addon.DragDrop onDragStart()
     * @returns {Object}
     * @protected
     */
    getMainThreadConfigs() {
        let me = this;

        return {
            alwaysFireDragMove : me.alwaysFireDragMove,
            boundaryContainerId: me.boundaryContainerId,
            dragElementRootId  : me.getDragElementRoot().id,
            dragProxyCls       : me.dragProxyCls,
            dragZoneId         : me.id,
            dropZoneIdentifier : me.dropZoneIdentifier,
            moveHorizontal     : me.moveHorizontal,
            moveVertical       : me.moveVertical,
            scrollContainerId  : me.scrollContainerId,
            scrollFactorLeft   : me.scrollFactorLeft,
            scrollFactorTop    : me.scrollFactorTop
        };
    }

    /**
     * You can either extend this class and override the handler or listen to the event from the outside
     * @param {Object} data
     */
    onDrop(data) {
        this.fire('drop', data);
    }

    /**
     * You can either extend this class and override the handler or listen to the event from the outside
     * @param {Object} data
     */
    onDropEnter(data) {
        this.fire('drop:enter', data);
    }

    /**
     * You can either extend this class and override the handler or listen to the event from the outside
     * @param {Object} data
     */
    onDropLeave(data) {
        this.fire('drop:leave', data);
    }

    /**
     *
     */
    resetData() {
        setTimeout(() => {
            this.data = null;
        }, 30);
    }

    /**
     * Extend this method for child classes to pass additional properties
     * @param {Object} data={}
     */
    setData(data={}) {
        let me = this;

        me.data = {
            dragElement: me.getDragElementRoot(),
            dragZoneId : me.id,
            ...data
        };
    }
}

Neo.applyClassConfig(DragZone);



/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jb3ZpZDE5LWdhbGxlcnkvLi9ub2RlX21vZHVsZXMvbmVvLm1qcy9zcmMvZHJhZ2dhYmxlL0RyYWdQcm94eUNvbXBvbmVudC5tanMiLCJ3ZWJwYWNrOi8vY292aWQxOS1nYWxsZXJ5Ly4vbm9kZV9tb2R1bGVzL25lby5tanMvc3JjL2RyYWdnYWJsZS9EcmFnWm9uZS5tanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXlDOztBQUV6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyx3REFBSTtBQUNyQyx3QkFBd0I7QUFDeEI7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzdEa0Q7QUFDUTtBQUNQO0FBQ0Q7O0FBRWxEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLG1EQUFJO0FBQzNCLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCO0FBQ3hCO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsWUFBWTtBQUNoQztBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsWUFBWTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixZQUFZO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFlBQVk7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixZQUFZO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix3QkFBd0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsWUFBWTtBQUNoQztBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFlBQVk7QUFDaEM7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG1CQUFtQjtBQUN2QztBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsWUFBWTtBQUNoQztBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IseURBQWM7QUFDdEM7O0FBRUE7QUFDQSw4QkFBOEIsNERBQWtCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxZQUFZOztBQUVoRTtBQUNBLDJCQUEyQixZQUFZO0FBQ3ZDLDJCQUEyQixvQ0FBb0M7QUFDL0QsMkJBQTJCLG9DQUFvQztBQUMvRCwyQkFBMkIsV0FBVztBQUN0QyxhQUFhOztBQUViO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVksd0RBQVk7QUFDeEI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDZCQUE2QjtBQUN2RCxhQUFhO0FBQ2IsU0FBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFFBQVEsMkRBQWU7QUFDdkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxnQ0FBZ0MsMEJBQTBCO0FBQzFEOztBQUVBO0FBQ0EsK0JBQStCLDBCQUEwQjtBQUN6RDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLFFBQVEsd0RBQVk7QUFDcEI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0EsbUJBQW1CO0FBQ25COztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwiZmlsZSI6ImNodW5rcy92ZW5kb3JzLW5vZGVfbW9kdWxlc19uZW9fbWpzX3NyY19kcmFnZ2FibGVfRHJhZ1pvbmVfbWpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IEJhc2UgZnJvbSAnLi4vY29tcG9uZW50L0Jhc2UubWpzJztcblxuLyoqXG4gKiBAY2xhc3MgTmVvLmRyYWdnYWJsZS5EcmFnUHJveHlDb21wb25lbnRcbiAqIEBleHRlbmRzIE5lby5jb21wb25lbnQuQmFzZVxuICovXG5jbGFzcyBEcmFnUHJveHlDb21wb25lbnQgZXh0ZW5kcyBCYXNlIHtcbiAgICBzdGF0aWMgZ2V0Q29uZmlnKCkge3JldHVybiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmRyYWdnYWJsZS5EcmFnUHJveHlDb21wb25lbnQnXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTmFtZTogJ05lby5kcmFnZ2FibGUuRHJhZ1Byb3h5Q29tcG9uZW50JyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ30gbnR5cGU9J2RyYWdwcm94eSdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbnR5cGU6ICdkcmFncHJveHknLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gYXV0b01vdW50PXRydWVcbiAgICAgICAgICovXG4gICAgICAgIGF1dG9Nb3VudDogdHJ1ZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IGF1dG9SZW5kZXI9dHJ1ZVxuICAgICAgICAgKi9cbiAgICAgICAgYXV0b1JlbmRlcjogdHJ1ZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ1tdfSBjbHM9WyduZW8tZHJhZ3Byb3h5J11cbiAgICAgICAgICovXG4gICAgICAgIGNsczogWyduZW8tZHJhZ3Byb3h5J10sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBtb3ZlSW5NYWluVGhyZWFkPXRydWVcbiAgICAgICAgICovXG4gICAgICAgIG1vdmVJbk1haW5UaHJlYWQ6IHRydWVcbiAgICB9fVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgICAgIHN1cGVyKGNvbmZpZyk7XG5cbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBtZS5vbignbW91bnRlZCcsIG1lLm9uTW91bnRlZCwgbWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGlkXG4gICAgICovXG4gICAgb25Nb3VudGVkKGlkKSB7XG4gICAgICAgIGlmICh0aGlzLm1vdmVJbk1haW5UaHJlYWQpIHtcbiAgICAgICAgICAgIE5lby5tYWluLmFkZG9uLkRyYWdEcm9wLnNldERyYWdQcm94eUVsZW1lbnQoe1xuICAgICAgICAgICAgICAgIGlkOiBpZFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbk5lby5hcHBseUNsYXNzQ29uZmlnKERyYWdQcm94eUNvbXBvbmVudCk7XG5cbmV4cG9ydCB7RHJhZ1Byb3h5Q29tcG9uZW50IGFzIGRlZmF1bHR9OyIsImltcG9ydCBCYXNlICAgICAgICAgICAgICAgZnJvbSAnLi4vY29yZS9CYXNlLm1qcyc7XG5pbXBvcnQgRHJhZ1Byb3h5Q29tcG9uZW50IGZyb20gJy4vRHJhZ1Byb3h5Q29tcG9uZW50Lm1qcyc7XG5pbXBvcnQgTmVvQXJyYXkgICAgICAgICAgIGZyb20gJy4uL3V0aWwvQXJyYXkubWpzJztcbmltcG9ydCBWRG9tVXRpbCAgICAgICAgICAgZnJvbSAnLi4vdXRpbC9WRG9tLm1qcyc7XG5cbi8qKlxuICogQGNsYXNzIE5lby5kcmFnZ2FibGUuRHJhZ1pvbmVcbiAqIEBleHRlbmRzIE5lby5jb3JlLkJhc2VcbiAqL1xuY2xhc3MgRHJhZ1pvbmUgZXh0ZW5kcyBCYXNlIHtcbiAgICBzdGF0aWMgZ2V0U3RhdGljQ29uZmlnKCkge3JldHVybiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUcnVlIGF1dG9tYXRpY2FsbHkgYXBwbGllcyB0aGUgY29yZS9PYnNlcnZhYmxlLm1qcyBtaXhpblxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBvYnNlcnZhYmxlPXRydWVcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKi9cbiAgICAgICAgb2JzZXJ2YWJsZTogdHJ1ZVxuICAgIH19XG5cbiAgICBzdGF0aWMgZ2V0Q29uZmlnKCkge3JldHVybiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IGNsYXNzTmFtZT0nTmVvLmRyYWdnYWJsZS5EcmFnWm9uZSdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgY2xhc3NOYW1lOiAnTmVvLmRyYWdnYWJsZS5EcmFnWm9uZScsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IG50eXBlPSdkcmFnem9uZSdcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgbnR5cGU6ICdkcmFnem9uZScsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBZGRzIHRoaXMuZHJhZ1Byb3h5Q2xzID0+ICduZW8tZHJhZ3Byb3h5JyB0byB0aGUgdG9wIGxldmVsIGRyYWdQcm94eUVsIG5vZGVcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gYWRkRHJhZ1Byb3h5Q2xzPXRydWVcbiAgICAgICAgICovXG4gICAgICAgIGFkZERyYWdQcm94eUNsczogdHJ1ZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGRyYWc6bW92ZSB3aWxsIGJ5IGRlZmF1bHQgb25seSBmaXJlIGluIGNhc2UgbW92ZUluTWFpblRocmVhZCA9PT0gZmFsc2UuXG4gICAgICAgICAqIEluIGNhc2UgeW91IHdhbnQgdG8gbW92ZSB0aGUgZHJhZ1Byb3h5IGluc2lkZSBtYWluIGJ1dCBzdGlsbCBnZXQgdGhlIGV2ZW50LFxuICAgICAgICAgKiBzZXQgdGhpcyBjb25maWcgdG8gdHJ1ZS5cbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gYWx3YXlzRmlyZURyYWdNb3ZlPWZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICBhbHdheXNGaXJlRHJhZ01vdmU6IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG5hbWUgb2YgdGhlIEFwcCB0aGlzIGluc3RhbmNlIGJlbG9uZ3MgdG9cbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfG51bGx9IGFwcE5hbWU9bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgYXBwTmFtZTogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZ3xudWxsfSBib3VuZGFyeUNvbnRhaW5lcklkPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIGJvdW5kYXJ5Q29udGFpbmVySWQ6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTdG9yZSBkYXRhIHdoaWNoIHlvdSB3YW50IHRvIHBhc3MgdG8gZHJvcCByZWxhdGVkIGV2ZW50cyBoZXJlXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdHxudWxsfSBkYXRhPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIGRhdGE6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdmRvbSAodHJlZSkgb2YgdGhlIGVsZW1lbnQgeW91IHdhbnQgdG8gZHJhZ1xuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R8bnVsbH0gZHJhZ0VsZW1lbnQ9bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgZHJhZ0VsZW1lbnQ6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgYm91bmRpbmcgY2xpZW50IHJlY3Qgb2YgdGhlIGRyYWdFbGVtZW50XG4gICAgICAgICAqIFdpbGwgZ2V0IHNldCBpbnNpZGUgZHJhZ1N0YXJ0KClcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fG51bGx9IGRyYWdFbGVtZW50UmVjdD1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBkcmFnRWxlbWVudFJlY3Q6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOZW8uY29tcG9uZW50LkJhc2V8bnVsbH0gZHJhZ1Byb3h5PW51bGxcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgZHJhZ1Byb3h5OiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fG51bGx9IGRyYWdQcm94eUNvbmZpZz1udWxsXG4gICAgICAgICAqL1xuICAgICAgICBkcmFnUHJveHlDb25maWdfOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBkcmFnUHJveHlDbHM9J25lby1kcmFncHJveHknXG4gICAgICAgICAqL1xuICAgICAgICBkcmFnUHJveHlDbHM6ICduZW8tZHJhZ3Byb3h5JyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFlvdSBjYW4gZWl0aGVyIHBhc3MgYW4gYXJyYXkgb2YgKGRvbSkgaWRzIG9yIGNscyBydWxlcyBvciBib3RoXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIGRyb3Bab25lSWRlbnRpZmllcjoge1xuICAgICAgICAgKiAgICAgaWRzOiBbJ2ZvbycsJ2JhciddXG4gICAgICAgICAqIH1cbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogZHJvcFpvbmVJZGVudGlmaWVyOiB7XG4gICAgICAgICAqICAgICBjbHM6IFsnbXktY2xhc3MtMScsJ215LWNsYXNzLTInXVxuICAgICAgICAgKiB9XG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIGRyb3Bab25lSWRlbnRpZmllcjoge1xuICAgICAgICAgKiAgICAgY2xzOiBbJ215LWNsYXNzLTEnLCdteS1jbGFzcy0yJ10sXG4gICAgICAgICAqICAgICBpZHM6IFsnZm9vJywnYmFyJ11cbiAgICAgICAgICogfVxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R8bnVsbH0gZHJvcFpvbmVJZGVudGlmaWVyPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIGRyb3Bab25lSWRlbnRpZmllcjogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge0Jvb2xlYW59IG1vdmVIb3Jpem9udGFsPXRydWVcbiAgICAgICAgICovXG4gICAgICAgIG1vdmVIb3Jpem9udGFsOiB0cnVlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gbW92ZUluTWFpblRocmVhZD10cnVlXG4gICAgICAgICAqL1xuICAgICAgICBtb3ZlSW5NYWluVGhyZWFkOiB0cnVlLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Qm9vbGVhbn0gbW92ZVZlcnRpY2FsPXRydWVcbiAgICAgICAgICovXG4gICAgICAgIG1vdmVWZXJ0aWNhbDogdHJ1ZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcn0gb2Zmc2V0WD0wXG4gICAgICAgICAqL1xuICAgICAgICBvZmZzZXRYOiAwLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyfSBvZmZzZXRZPTBcbiAgICAgICAgICovXG4gICAgICAgIG9mZnNldFk6IDAsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOZW8uY29tcG9uZW50LkJhc2V9IG93bmVyPW51bGxcbiAgICAgICAgICovXG4gICAgICAgIG93bmVyOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBwcm94eVBhcmVudElkXz0nZG9jdW1lbnQuYm9keSdcbiAgICAgICAgICovXG4gICAgICAgIHByb3h5UGFyZW50SWRfOiAnZG9jdW1lbnQuYm9keScsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd8bnVsbH0gc2Nyb2xsQ29udGFpbmVySWQ9bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgc2Nyb2xsQ29udGFpbmVySWQ6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9IHNjcm9sbEZhY3RvckxlZnQ9MVxuICAgICAgICAgKi9cbiAgICAgICAgc2Nyb2xsRmFjdG9yTGVmdDogMSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge051bWJlcn0gc2Nyb2xsRmFjdG9yVG9wPTFcbiAgICAgICAgICovXG4gICAgICAgIHNjcm9sbEZhY3RvclRvcDogMSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRydWUgY3JlYXRlcyBhIHBvc2l0aW9uOmFic29sdXRlIHdyYXBwZXIgZGl2IHdoaWNoIGNvbnRhaW5zIHRoZSBjbG9uZWQgZWxlbWVudFxuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufSB1c2VQcm94eVdyYXBwZXI9dHJ1ZVxuICAgICAgICAgKi9cbiAgICAgICAgdXNlUHJveHlXcmFwcGVyOiB0cnVlXG4gICAgfX1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgICAgICBzdXBlcihjb25maWcpO1xuXG4gICAgICAgIGlmICghTmVvLm1haW4uYWRkb24uRHJhZ0Ryb3ApIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1lvdSBjYW4gbm90IHVzZSBOZW8uZHJhZ2dhYmxlLkRyYWdab25lIHdpdGhvdXQgYWRkaW5nIE5lby5tYWluLmFkZG9uLkRyYWdEcm9wIHRvIHRoZSBtYWluIHRocmVhZCBhZGRvbnMnLCB0aGlzLmlkKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCB3aGVuIGFjY2Vzc2luZyB0aGUgZHJhZ1Byb3h5Q29uZmlnIGNvbmZpZ1xuICAgICAqIFdlIGFyZSByZS11c2luZyB0aGlzIGNvbmZpZyB0byBjcmVhdGUgbXVsdGlwbGUgZHJhZ1Byb3hpZXMsXG4gICAgICogc28gaXQgaXMgaW1wb3J0YW50IHRvIHdvcmsgd2l0aCBhIGNsb25lLiBzZWU6IGNyZWF0ZURyYWdQcm94eSgpXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGJlZm9yZUdldERyYWdQcm94eUNvbmZpZyh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gTmVvLmNsb25lKHZhbHVlLCB0cnVlLCB0cnVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgY3JlYXRlRHJhZ1Byb3h5KGRhdGEpIHtcbiAgICAgICAgbGV0IG1lICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgICBjb21wb25lbnQgPSBOZW8uZ2V0Q29tcG9uZW50KG1lLmdldERyYWdFbGVtZW50Um9vdCgpLmlkKSB8fCBtZS5vd25lcixcbiAgICAgICAgICAgIGNsb25lICAgICA9IFZEb21VdGlsLmNsb25lKG1lLmRyYWdFbGVtZW50KSxcbiAgICAgICAgICAgIHJlY3QgICAgICA9IG1lLmRyYWdFbGVtZW50UmVjdDtcblxuICAgICAgICBjb25zdCBjb25maWcgPSB7XG4gICAgICAgICAgICBtb2R1bGUgICAgICAgICAgOiBEcmFnUHJveHlDb21wb25lbnQsXG4gICAgICAgICAgICBhcHBOYW1lICAgICAgICAgOiBtZS5hcHBOYW1lLFxuICAgICAgICAgICAgbW92ZUluTWFpblRocmVhZDogbWUubW92ZUluTWFpblRocmVhZCxcbiAgICAgICAgICAgIHBhcmVudElkICAgICAgICA6IG1lLnByb3h5UGFyZW50SWQsXG4gICAgICAgICAgICB2ZG9tICAgICAgICAgICAgOiBtZS51c2VQcm94eVdyYXBwZXIgPyB7Y246IFtjbG9uZV19IDogY2xvbmUsXG5cbiAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBgJHtkYXRhLmhlaWdodH1weGAsXG4gICAgICAgICAgICAgICAgbGVmdCAgOiBgJHttZS5tb3ZlSG9yaXpvbnRhbCA/IGRhdGEueCA6IHJlY3QueH1weGAsXG4gICAgICAgICAgICAgICAgdG9wICAgOiBgJHttZS5tb3ZlVmVydGljYWwgICA/IGRhdGEueSA6IHJlY3QueX1weGAsXG4gICAgICAgICAgICAgICAgd2lkdGggOiBgJHtkYXRhLndpZHRofXB4YFxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLi4ubWUuZHJhZ1Byb3h5Q29uZmlnIHx8IHt9XG4gICAgICAgIH07XG5cbiAgICAgICAgY29uZmlnLmNscyA9IGNvbmZpZy5jbHMgfHwgW107XG5cbiAgICAgICAgaWYgKGNvbXBvbmVudCkge1xuICAgICAgICAgICAgY29uZmlnLmNscy5wdXNoKGNvbXBvbmVudC5nZXRUaGVtZSgpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghbWUudXNlUHJveHlXcmFwcGVyKSB7XG4gICAgICAgICAgICBjb25maWcuY2xzLnB1c2goLi4uY2xvbmUuY2xzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtZS5hZGREcmFnUHJveHlDbHMgJiYgY29uZmlnLmNscykge1xuICAgICAgICAgICAgTmVvQXJyYXkuYWRkKGNvbmZpZy5jbHMsIG1lLmRyYWdQcm94eUNscyk7XG4gICAgICAgIH1cblxuICAgICAgICBtZS5kcmFnUHJveHkgPSBOZW8uY3JlYXRlKGNvbmZpZyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGUgZm9yIHVzaW5nIGN1c3RvbSBhbmltYXRpb25zXG4gICAgICovXG4gICAgZGVzdHJveURyYWdQcm94eSgpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcyxcbiAgICAgICAgICAgIGlkID0gbWUuZHJhZ1Byb3h5LmlkO1xuXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgTmVvLmN1cnJlbnRXb3JrZXIucHJvbWlzZU1lc3NhZ2UoJ21haW4nLCB7XG4gICAgICAgICAgICAgICAgYWN0aW9uOiAndXBkYXRlRG9tJyxcbiAgICAgICAgICAgICAgICBkZWx0YXM6IFt7YWN0aW9uOiAncmVtb3ZlTm9kZScsIGlkOiBpZH1dXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSwgbWUubW92ZUluTWFpblRocmVhZCA/IDAgOiAzMCk7XG5cbiAgICAgICAgbWUuZHJhZ1Byb3h5LmRlc3Ryb3koKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIGRyYWdFbmQoKSB7XG4gICAgICAgIGxldCBtZSAgICA9IHRoaXMsXG4gICAgICAgICAgICBvd25lciA9IG1lLm93bmVyLFxuICAgICAgICAgICAgY2xzICAgPSBvd25lci5jbHM7XG5cbiAgICAgICAgTmVvQXJyYXkucmVtb3ZlKGNscywgJ25lby1pcy1kcmFnZ2luZycpO1xuICAgICAgICBvd25lci5jbHMgPSBjbHM7XG5cbiAgICAgICAgaWYgKG1lLmRyYWdQcm94eSkge1xuICAgICAgICAgICAgbWUuZGVzdHJveURyYWdQcm94eSgpO1xuICAgICAgICAgICAgbWUuZHJhZ1Byb3h5ID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIE9iamVjdC5hc3NpZ24obWUsIHtcbiAgICAgICAgICAgIGRyYWdFbGVtZW50UmVjdCAgOiBudWxsLFxuICAgICAgICAgICAgb2Zmc2V0WCAgICAgICAgICA6IDAsXG4gICAgICAgICAgICBvZmZzZXRZICAgICAgICAgIDogMCxcbiAgICAgICAgICAgIHNjcm9sbENvbnRhaW5lcklkOiBudWxsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIG1lLnJlc2V0RGF0YSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKi9cbiAgICBkcmFnTW92ZShkYXRhKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXMsXG4gICAgICAgICAgICBzdHlsZTtcblxuICAgICAgICBpZiAoIW1lLm1vdmVJbk1haW5UaHJlYWQgJiYgbWUuZHJhZ1Byb3h5KSB7XG4gICAgICAgICAgICBzdHlsZSA9IG1lLmRyYWdQcm94eS5zdHlsZTtcblxuICAgICAgICAgICAgaWYgKG1lLm1vdmVIb3Jpem9udGFsKSB7XG4gICAgICAgICAgICAgICAgc3R5bGUubGVmdCA9IGAke2RhdGEuY2xpZW50WCAtIG1lLm9mZnNldFh9cHhgO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobWUubW92ZVZlcnRpY2FsKSB7XG4gICAgICAgICAgICAgICAgc3R5bGUudG9wID0gYCR7ZGF0YS5jbGllbnRZIC0gbWUub2Zmc2V0WX1weGA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG1lLmRyYWdQcm94eS5zdHlsZSA9IHN0eWxlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIGRyYWdTdGFydChkYXRhKSB7XG4gICAgICAgIGxldCBtZSAgICA9IHRoaXMsXG4gICAgICAgICAgICBvd25lciA9IG1lLm93bmVyLFxuICAgICAgICAgICAgY2xzICAgPSBvd25lci5jbHM7XG5cbiAgICAgICAgbWUuc2V0RGF0YSgpO1xuXG4gICAgICAgIE5lb0FycmF5LmFkZChjbHMsICduZW8taXMtZHJhZ2dpbmcnKTtcbiAgICAgICAgb3duZXIuY2xzID0gY2xzO1xuXG4gICAgICAgIE5lby5tYWluLmFkZG9uLkRyYWdEcm9wLnNldENvbmZpZ3MobWUuZ2V0TWFpblRocmVhZENvbmZpZ3MoKSk7XG5cbiAgICAgICAgTmVvLm1haW4uRG9tQWNjZXNzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCh7XG4gICAgICAgICAgICBpZDogbWUuZ2V0RHJhZ0VsZW1lbnRSb290KCkuaWRcbiAgICAgICAgfSkudGhlbihyZWN0ID0+IHtcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24obWUsIHtcbiAgICAgICAgICAgICAgICBkcmFnRWxlbWVudFJlY3Q6IHJlY3QsXG4gICAgICAgICAgICAgICAgb2Zmc2V0WCAgICAgICAgOiBkYXRhLmNsaWVudFggLSByZWN0LmxlZnQsXG4gICAgICAgICAgICAgICAgb2Zmc2V0WSAgICAgICAgOiBkYXRhLmNsaWVudFkgLSByZWN0LnRvcFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIG1lLmNyZWF0ZURyYWdQcm94eShyZWN0KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGUgdGhpcyBtZXRob2QgaW4gY2FzZSB5b3Ugd2FudCB0byB3cmFwIHlvdXIgZHJhZ0VsZW1lbnQuXG4gICAgICogU2VlOiBkcmFnZ2FibGUudHJlZS5EcmFnWm9uZVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgZ2V0RHJhZ0VsZW1lbnRSb290KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kcmFnRWxlbWVudDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZSB0aGlzIG1ldGhvZCBpbnNpZGUgY2xhc3MgZXh0ZW5zaW9ucyB0byBhZGQgbW9yZSBjb25maWdzXG4gICAgICogd2hpY2ggZ2V0IHBhc3NlZCB0byBtYWluLmFkZG9uLkRyYWdEcm9wIG9uRHJhZ1N0YXJ0KClcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBnZXRNYWluVGhyZWFkQ29uZmlncygpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYWx3YXlzRmlyZURyYWdNb3ZlIDogbWUuYWx3YXlzRmlyZURyYWdNb3ZlLFxuICAgICAgICAgICAgYm91bmRhcnlDb250YWluZXJJZDogbWUuYm91bmRhcnlDb250YWluZXJJZCxcbiAgICAgICAgICAgIGRyYWdFbGVtZW50Um9vdElkICA6IG1lLmdldERyYWdFbGVtZW50Um9vdCgpLmlkLFxuICAgICAgICAgICAgZHJhZ1Byb3h5Q2xzICAgICAgIDogbWUuZHJhZ1Byb3h5Q2xzLFxuICAgICAgICAgICAgZHJhZ1pvbmVJZCAgICAgICAgIDogbWUuaWQsXG4gICAgICAgICAgICBkcm9wWm9uZUlkZW50aWZpZXIgOiBtZS5kcm9wWm9uZUlkZW50aWZpZXIsXG4gICAgICAgICAgICBtb3ZlSG9yaXpvbnRhbCAgICAgOiBtZS5tb3ZlSG9yaXpvbnRhbCxcbiAgICAgICAgICAgIG1vdmVWZXJ0aWNhbCAgICAgICA6IG1lLm1vdmVWZXJ0aWNhbCxcbiAgICAgICAgICAgIHNjcm9sbENvbnRhaW5lcklkICA6IG1lLnNjcm9sbENvbnRhaW5lcklkLFxuICAgICAgICAgICAgc2Nyb2xsRmFjdG9yTGVmdCAgIDogbWUuc2Nyb2xsRmFjdG9yTGVmdCxcbiAgICAgICAgICAgIHNjcm9sbEZhY3RvclRvcCAgICA6IG1lLnNjcm9sbEZhY3RvclRvcFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFlvdSBjYW4gZWl0aGVyIGV4dGVuZCB0aGlzIGNsYXNzIGFuZCBvdmVycmlkZSB0aGUgaGFuZGxlciBvciBsaXN0ZW4gdG8gdGhlIGV2ZW50IGZyb20gdGhlIG91dHNpZGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uRHJvcChkYXRhKSB7XG4gICAgICAgIHRoaXMuZmlyZSgnZHJvcCcsIGRhdGEpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFlvdSBjYW4gZWl0aGVyIGV4dGVuZCB0aGlzIGNsYXNzIGFuZCBvdmVycmlkZSB0aGUgaGFuZGxlciBvciBsaXN0ZW4gdG8gdGhlIGV2ZW50IGZyb20gdGhlIG91dHNpZGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIG9uRHJvcEVudGVyKGRhdGEpIHtcbiAgICAgICAgdGhpcy5maXJlKCdkcm9wOmVudGVyJywgZGF0YSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogWW91IGNhbiBlaXRoZXIgZXh0ZW5kIHRoaXMgY2xhc3MgYW5kIG92ZXJyaWRlIHRoZSBoYW5kbGVyIG9yIGxpc3RlbiB0byB0aGUgZXZlbnQgZnJvbSB0aGUgb3V0c2lkZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICovXG4gICAgb25Ecm9wTGVhdmUoZGF0YSkge1xuICAgICAgICB0aGlzLmZpcmUoJ2Ryb3A6bGVhdmUnLCBkYXRhKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIHJlc2V0RGF0YSgpIHtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmRhdGEgPSBudWxsO1xuICAgICAgICB9LCAzMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXh0ZW5kIHRoaXMgbWV0aG9kIGZvciBjaGlsZCBjbGFzc2VzIHRvIHBhc3MgYWRkaXRpb25hbCBwcm9wZXJ0aWVzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGE9e31cbiAgICAgKi9cbiAgICBzZXREYXRhKGRhdGE9e30pIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcblxuICAgICAgICBtZS5kYXRhID0ge1xuICAgICAgICAgICAgZHJhZ0VsZW1lbnQ6IG1lLmdldERyYWdFbGVtZW50Um9vdCgpLFxuICAgICAgICAgICAgZHJhZ1pvbmVJZCA6IG1lLmlkLFxuICAgICAgICAgICAgLi4uZGF0YVxuICAgICAgICB9O1xuICAgIH1cbn1cblxuTmVvLmFwcGx5Q2xhc3NDb25maWcoRHJhZ1pvbmUpO1xuXG5leHBvcnQge0RyYWdab25lIGFzIGRlZmF1bHR9OyJdLCJzb3VyY2VSb290IjoiIn0=